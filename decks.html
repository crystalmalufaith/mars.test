<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mars.ai - Flashcard Decks</title>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script>
  pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
</script>
<script src="https://cdn.jsdelivr.net/npm/nanoid@3/nanoid.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

<link rel="stylesheet" href="style.css">
</head>
<body>

<div class="header">
  <button id="sidebar-toggle" style="background: none; border: none; color: white; font-size: 24px; cursor: pointer;">â˜°</button>
  <h1>Mars.ai</h1>
  <div></div>
</div>

<div class="sidebar">
  <nav class="nav">
    <a href="index.html">AI Tutor</a>
    <a href="decks.html">Decks</a>
    <a href="docs.html">Docs</a>
    <a href="quiz.html">Quiz</a>
    <a href="stats.html">Stats</a>
    <a href="community.html">Community</a>
    <a href="about.html">About</a>
    <a href="terms.html">Terms</a>
    <a href="#" id="account-link">Account</a>
  </nav>
</div>

<div class="main-section">
  <div class="main-container">
    <div class="page-header">
      <h1>Flashcard Decks</h1>
    </div>

    <div class="create-deck">
      <form id="create-deck-form">
        <input type="text" id="deck-name" placeholder="Enter deck name" required>
        <button type="submit">Create Deck</button>
      </form>
      <button id="add-from-content-btn" style="margin-top: 1rem; padding: 0.75rem 1.5rem; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Add from Content</button>
    </div>

    <div class="decks-grid" id="decks-container">
      <!-- Decks will be loaded here -->
    </div>
  </div>
</div>

<div class="modal" id="deck-modal">
  <div class="modal-content">
    <h2 id="modal-title">Edit Deck</h2>
    <form id="deck-form" novalidate>
      <input type="text" id="edit-deck-name" placeholder="Deck name">
      <div class="flashcards" id="flashcards-list">
        <!-- Flashcards will be listed here -->
      </div>
      <h3>Add New Flashcard</h3>
      <input type="text" id="card-front" placeholder="Front (question)" required>
      <textarea id="card-back" placeholder="Back (answer)" required></textarea>
      <button type="button" onclick="addFlashcard()" class="add-flashcard-btn">Add Flashcard</button>

      <h3>Add AI Generated Flashcards</h3>
      <textarea id="ai-content-text" placeholder="Paste text content to generate flashcards from..." rows="3"></textarea>
      <input type="file" id="ai-content-file" accept=".txt,.pdf,.jpg,.png,.jpeg" style="margin-bottom: 1rem;">
      <div id="ai-loading-indicator" style="display: none; color: #e0e0e0; text-align: center; margin: 1rem 0;">Generating flashcards...</div>
      <button type="button" onclick="generateAIFlashcards()" class="add-flashcard-btn">Generate AI Flashcards</button>

      <div class="modal-actions">
        <button type="button" onclick="closeModal()">Cancel</button>
        <button type="submit">Save Changes</button>
      </div>
    </form>
  </div>
</div>

<div class="modal" id="study-modal">
  <div class="modal-content">
    <h2 id="study-deck-name">Study Deck</h2>
    <div id="study-card" style="text-align: center; padding: 2rem; background: #333; border-radius: 8px; margin: 1rem 0; cursor: pointer; min-height: 200px; display: flex; align-items: center; justify-content: center; color: #e0e0e0;">
      <div id="card-content">Click to reveal answer</div>
    </div>
    <div style="display: flex; justify-content: space-between; align-items: center;">
      <button onclick="previousCard()" id="prev-btn" class="study-btn">Previous</button>
      <span id="card-counter">1 / 1</span>
      <button onclick="nextCard()" id="next-btn" class="study-btn">Next</button>
    </div>
    <div style="text-align: center; margin-top: 1rem;">
      <button onclick="closeStudyModal()" style="background: #4e4e4e; color: white; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer;">Close</button>
    </div>
  </div>
</div>

<div class="modal" id="content-modal">
  <div class="modal-content">
    <h2>Add Flashcards from Content</h2>
    <form id="content-form">
      <label for="content-deck-select">Select Deck:</label>
      <select id="content-deck-select">
        <option value="new">Create New Deck</option>
      </select>
      <label for="content-new-deck-name" id="new-deck-label" style="display: none;">New Deck Name:</label>
      <input type="text" id="content-new-deck-name" placeholder="Enter new deck name" style="display: none;">
      <label for="content-text">Paste Text:</label>
      <textarea id="content-text" placeholder="Paste your text here..." rows="5"></textarea>
      <label for="content-file">Upload Image or PDF:</label>
      <input type="file" id="content-file" accept=".txt,.pdf,.jpg,.png,.jpeg">
      <div id="loading-indicator" style="display: none; color: #e0e0e0; text-align: center; margin: 1rem 0;">Generating flashcards...</div>
      <div class="modal-actions">
        <button type="button" onclick="closeContentModal()">Cancel</button>
        <button type="submit" id="generate-btn">Generate Flashcards</button>
      </div>
    </form>
  </div>
</div>

<div class="modal" id="account-modal">
  <div class="modal-content">
    <h2>Account</h2>
    <div id="account-info">
      <!-- Account info will be loaded here -->
    </div>
  </div>
</div>

<script>
const user = JSON.parse(localStorage.getItem('currentUser'));
if (!user) {
  window.location.href = 'sign-in.html?redirect=' + encodeURIComponent(window.location.href);
}

let currentDeckId = null;
let currentCardIndex = 0;
let showCard = false;
let decks = JSON.parse(localStorage.getItem('flashcardDecks_' + user.id)) || [];

// Ensure all decks have cards array
decks.forEach(deck => {
  if (!deck.cards) {
    deck.cards = [];
  }
});
saveDecks();

function saveDecks() {
  localStorage.setItem('flashcardDecks_' + user.id, JSON.stringify(decks));
}

function renderDecks() {
  const container = document.getElementById('decks-container');
  container.innerHTML = '';

  decks.forEach((deck, index) => {
    const deckCard = document.createElement('div');
    deckCard.className = 'deck-card';
    deckCard.innerHTML = `
      <h3>${deck.name}</h3>
      <p>${deck.cards ? deck.cards.length : 0} cards</p>
      <div class="deck-actions">
        <button onclick="studyDeck(${index})">Study</button>
        <button onclick="editDeck(${index})">Edit</button>
        <button onclick="shareDeck(${index})">Share</button>
        <button class="delete" onclick="deleteDeck(${index})">Delete</button>
      </div>
    `;
    container.appendChild(deckCard);
  });
}

function createDeck(name) {
  const newDeck = {
    id: nanoid(),
    name: name,
    cards: []
  };
  decks.push(newDeck);
  saveDecks();
  renderDecks();
}

function editDeck(index) {
  currentDeckId = index;
  const deck = decks[index];
  document.getElementById('modal-title').textContent = 'Edit Deck';
  document.getElementById('edit-deck-name').value = deck.name;
  renderFlashcards(deck.cards);
  document.getElementById('deck-modal').classList.add('show');
}

function deleteDeck(index) {
  if (confirm('Are you sure you want to delete this deck?')) {
    decks.splice(index, 1);
    saveDecks();
    renderDecks();
  }
}

async function shareDeck(index) {
  const deck = decks[index];
  const shareData = {
    name: deck.name,
    cards: deck.cards
  };
  const json = JSON.stringify(shareData);
  const gzipped = pako.gzip(json);
  const base64 = btoa(String.fromCharCode(...gzipped));
  const compressed = encodeURIComponent(base64);
  const longUrl = `${window.location.origin}/decks.html#shared=${compressed}`;

  try {
    const shortResponse = await fetch(`https://is.gd/create.php?format=simple&url=${encodeURIComponent(longUrl)}`);
    const shortUrl = await shortResponse.text();
    navigator.clipboard.writeText(shortUrl).then(() => {
      alert('Share link copied to clipboard!');
    }).catch(() => {
      alert(`Share this link: ${shortUrl}`);
    });
  } catch (e) {
    // Fallback to long URL if shortener fails
    navigator.clipboard.writeText(longUrl).then(() => {
      alert('Share link copied to clipboard!');
    }).catch(() => {
      alert(`Share this link: ${longUrl}`);
    });
  }
}

function showSharedDeckView(shareData) {
  // Add to community
  addSharedDeckToCommunity(shareData);

  // Show the deck
  document.getElementById('study-deck-name').textContent = shareData.name;
  document.getElementById('study-modal').classList.add('show');
  currentDeckId = 'shared';
  currentCardIndex = 0;
  showCard = false;
  // Temporarily set the cards
  const tempDeck = { cards: shareData.cards };
  // Override updateStudyCard to use tempDeck
  const originalUpdate = updateStudyCard;
  updateStudyCard = function() {
    const card = tempDeck.cards[currentCardIndex];
    const cardContent = document.getElementById('card-content');
    const counter = document.getElementById('card-counter');

    counter.textContent = `${currentCardIndex + 1} / ${tempDeck.cards.length}`;

    if (showCard) {
      cardContent.innerHTML = `<strong>Answer:</strong><br>${card.back}`;
    } else {
      cardContent.innerHTML = `<strong>Question:</strong><br>${card.front}`;
    }

    // Render math if present
    renderMathInElement(cardContent, {
      delimiters: [
        {left: "$$", right: "$$", display: true},
        {left: "$", right: "$", display: false},
        {left: "\\(", right: "\\)", display: false}
      ]
    });

    document.getElementById('prev-btn').disabled = currentCardIndex === 0;
    document.getElementById('next-btn').disabled = currentCardIndex === tempDeck.cards.length - 1;
  };
  updateStudyCard();
}

function addSharedDeckToCommunity(shareData) {
  let sharedDecks = JSON.parse(localStorage.getItem('sharedDecks')) || [];
  // Check if already in community
  if (sharedDecks.some(d => d.name === shareData.name && JSON.stringify(d.cards) === JSON.stringify(shareData.cards))) {
    return; // Already added
  }

  const sharedDeck = {
    id: 'shared-' + Date.now(),
    name: shareData.name,
    cards: shareData.cards,
    sharedBy: 'Shared Link',
    date: new Date().toISOString()
  };

  sharedDecks.push(sharedDeck);
  localStorage.setItem('sharedDecks', JSON.stringify(sharedDecks));
}


function studyDeck(index) {
  const deck = decks[index];
  if (!deck.cards || deck.cards.length === 0) {
    alert('This deck has no cards yet. Add some cards first!');
    return;
  }

  currentDeckId = index;
  currentCardIndex = 0;
  showCard = false;
  document.getElementById('study-deck-name').textContent = deck.name;
  document.getElementById('study-modal').classList.add('show');
  updateStudyCard();
}

function renderFlashcards(cards) {
  const container = document.getElementById('flashcards-list');
  container.innerHTML = '';

  if (!cards || cards.length === 0) {
    container.innerHTML = '<p>No flashcards yet. Add some cards below.</p>';
    return;
  }

  cards.forEach((card, index) => {
    const cardDiv = document.createElement('div');
    cardDiv.className = 'flashcard';
    cardDiv.innerHTML = `
      <strong>Front:</strong> ${card.front}<br>
      <strong>Back:</strong> ${card.back}
      <div class="flashcard-actions">
        <button onclick="editFlashcard(${index})">Edit</button>
        <button class="delete" onclick="deleteFlashcard(${index})">Delete</button>
      </div>
    `;
    container.appendChild(cardDiv);
  });
}

function addFlashcard() {
  const front = document.getElementById('card-front').value.trim();
  const back = document.getElementById('card-back').value.trim();

  if (!front || !back) {
    alert('Please fill in both front and back of the card.');
    return;
  }

  const deck = decks[currentDeckId];
  deck.cards.push({ front, back });
  saveDecks();
  renderDecks();

  document.getElementById('card-front').value = '';
  document.getElementById('card-back').value = '';
  renderFlashcards(deck.cards);
}

function editFlashcard(index) {
  const deck = decks[currentDeckId];
  const card = deck.cards[index];

  // Create a simple edit form
  const newFront = prompt('Edit front (question):', card.front);
  const newBack = prompt('Edit back (answer):', card.back);

  if (newFront !== null && newBack !== null) {
    deck.cards[index] = { front: newFront.trim(), back: newBack.trim() };
    saveDecks();
    renderFlashcards(deck.cards);
  }
}

async function generateAIFlashcards() {
  const text = document.getElementById('ai-content-text').value.trim();
  const fileInput = document.getElementById('ai-content-file');
  const loading = document.getElementById('ai-loading-indicator');
  const generateBtn = document.querySelector('button[onclick="generateAIFlashcards()"]');

  let content = text;

  if (fileInput.files.length > 0) {
    const file = fileInput.files[0];
    if (file.type === 'application/pdf') {
      content = await extractPDFText(file);
    } else if (file.type.startsWith('image/')) {
      alert('Image processing not yet supported. Please paste text instead.');
      return;
    } else {
      alert('Unsupported file type.');
      return;
    }
  }

  if (!content) {
    alert('Please provide text or upload a PDF.');
    return;
  }

  // Show loading
  loading.style.display = 'block';
  generateBtn.disabled = true;
  generateBtn.textContent = 'Generating...';

  try {
    // Generate Q&A for current deck
    const qas = await generateQA(content);

    // Add to current deck
    const deck = decks[currentDeckId];
    qas.forEach(qa => {
      deck.cards.push(qa);
    });

    saveDecks();
    renderDecks();
    renderFlashcards(deck.cards);

    // Clear inputs
    document.getElementById('ai-content-text').value = '';
    fileInput.value = '';

    alert(`Added ${qas.length} AI-generated flashcards to the deck!`);
  } catch (error) {
    alert('Error generating flashcards: ' + error.message);
  } finally {
    // Hide loading
    loading.style.display = 'none';
    generateBtn.disabled = false;
    generateBtn.textContent = 'Generate AI Flashcards';
  }
}

function deleteFlashcard(index) {
  const deck = decks[currentDeckId];
  deck.cards.splice(index, 1);
  saveDecks();
  renderDecks();
  renderFlashcards(deck.cards);
}

function closeModal() {
  document.getElementById('deck-modal').classList.remove('show');
  currentDeckId = null;
}

// Add outside click handlers for modals
document.addEventListener('click', function(e) {
  const deckModal = document.getElementById('deck-modal');
  const studyModal = document.getElementById('study-modal');
  const contentModal = document.getElementById('content-modal');

  if (e.target === deckModal) {
    closeModal();
  }
  if (e.target === studyModal) {
    closeStudyModal();
  }
  if (e.target === contentModal) {
    closeContentModal();
  }
});

function updateStudyCard() {
  const deck = decks[currentDeckId];
  const card = deck.cards[currentCardIndex];
  const cardContent = document.getElementById('card-content');
  const counter = document.getElementById('card-counter');

  counter.textContent = `${currentCardIndex + 1} / ${deck.cards.length}`;

  if (showCard) {
    cardContent.innerHTML = `<strong>Answer:</strong><br>${card.back}`;
  } else {
    cardContent.innerHTML = `<strong>Question:</strong><br>${card.front}`;
  }

  // Render math if present
  renderMathInElement(cardContent, {
    delimiters: [
      {left: "$$", right: "$$", display: true},
      {left: "$", right: "$", display: false},
      {left: "\\(", right: "\\)", display: false}
    ]
  });

  document.getElementById('prev-btn').disabled = currentCardIndex === 0;
  document.getElementById('next-btn').disabled = currentCardIndex === deck.cards.length - 1;
}

function flipCard() {
  showCard = !showCard;
  updateStudyCard();
}

function nextCard() {
  const deck = decks[currentDeckId];
  if (currentCardIndex < deck.cards.length - 1) {
    currentCardIndex++;
    showCard = false;
    updateStudyCard();
  }
}

function previousCard() {
  if (currentCardIndex > 0) {
    currentCardIndex--;
    showCard = false;
    updateStudyCard();
  }
}

function closeStudyModal() {
  document.getElementById('study-modal').classList.remove('show');
  currentDeckId = null;
  currentCardIndex = 0;
  showCard = false;
}

// Add click event to flip card
document.getElementById('study-card').addEventListener('click', flipCard);

// Event listeners
document.getElementById('create-deck-form').addEventListener('submit', (e) => {
  e.preventDefault();
  const name = document.getElementById('deck-name').value.trim();
  if (name) {
    createDeck(name);
    document.getElementById('deck-name').value = '';
  }
});

document.getElementById('deck-form').addEventListener('submit', (e) => {
  e.preventDefault();
  const name = document.getElementById('edit-deck-name').value.trim();
  if (name && currentDeckId !== null) {
    decks[currentDeckId].name = name;
    saveDecks();
    renderDecks();
    closeModal();
  }
});

// Check for shared deck in URL
const hash = window.location.hash;
const shared = hash.startsWith('#shared=') ? hash.substring(8) : null;

if (shared) {
  try {
    const base64 = decodeURIComponent(shared);
    const binaryString = atob(base64);
    const gzipped = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      gzipped[i] = binaryString.charCodeAt(i);
    }
    const decompressed = pako.ungzip(gzipped, {to: 'string'});
    const shareData = JSON.parse(decompressed);
    showSharedDeckView(shareData);
  } catch (e) {
    alert('Invalid share link');
  }
}

// Initial render
renderDecks();

// Add from content
document.getElementById('add-from-content-btn').addEventListener('click', () => {
  openContentModal();
});

function openContentModal() {
  const modal = document.getElementById('content-modal');
  const select = document.getElementById('content-deck-select');

  // Load decks
  select.innerHTML = '<option value="new">Create New Deck</option>';
  decks.forEach(deck => {
    const option = document.createElement('option');
    option.value = deck.id;
    option.textContent = deck.name;
    select.appendChild(option);
  });

  // If "Create New Deck" is selected (default), show the input
  if (select.value === 'new') {
    document.getElementById('content-new-deck-name').style.display = 'block';
    document.getElementById('new-deck-label').style.display = 'block';
    document.getElementById('content-new-deck-name').required = true;
  }

  modal.classList.add('show');
}

function closeContentModal() {
  document.getElementById('content-modal').classList.remove('show');
}

// Event listener for content deck select
document.getElementById('content-deck-select').addEventListener('change', (e) => {
  const newName = document.getElementById('content-new-deck-name');
  const newLabel = document.getElementById('new-deck-label');
  if (e.target.value === 'new') {
    newName.style.display = 'block';
    newLabel.style.display = 'block';
    newName.required = true;
  } else {
    newName.style.display = 'none';
    newLabel.style.display = 'none';
    newName.required = false;
  }
});

// Content form submit
document.getElementById('content-form').addEventListener('submit', async (e) => {
  e.preventDefault();
  const select = document.getElementById('content-deck-select');
  const newName = document.getElementById('content-new-deck-name');
  const text = document.getElementById('content-text').value.trim();
  const fileInput = document.getElementById('content-file');
  const loading = document.getElementById('loading-indicator');
  const generateBtn = document.getElementById('generate-btn');

  let content = text;

  if (fileInput.files.length > 0) {
    const file = fileInput.files[0];
    if (file.type === 'application/pdf') {
      content = await extractPDFText(file);
    } else if (file.type.startsWith('image/')) {
      alert('Image processing not yet supported. Please paste text instead.');
      return;
    } else {
      alert('Unsupported file type.');
      return;
    }
  }

  if (!content) {
    alert('Please provide text or upload a PDF.');
    return;
  }

  let deckId;

  if (select.value === 'new') {
    const name = newName.value.trim();
    if (!name) return;
    const newDeck = {
      id: nanoid(),
      name: name,
      cards: []
    };
    decks.push(newDeck);
    deckId = newDeck.id;
  } else {
    deckId = select.value;
  }

  // Show loading
  loading.style.display = 'block';
  generateBtn.disabled = true;
  generateBtn.textContent = 'Generating...';

  try {
    // Generate Q&A
    const qas = await generateQA(content);

    // Add to deck
    const targetDeck = decks.find(d => d.id == deckId);
    if (targetDeck) {
      qas.forEach(qa => {
        targetDeck.cards.push(qa);
      });
    }

    saveDecks();
    renderDecks();
    closeContentModal();
  } catch (error) {
    alert('Error generating flashcards: ' + error.message);
  } finally {
    // Hide loading
    loading.style.display = 'none';
    generateBtn.disabled = false;
    generateBtn.textContent = 'Generate Flashcards';
  }
});

async function extractPDFText(file) {
  const pdfjsLib = window['pdfjsLib'];
  pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

  const pdf = await pdfjsLib.getDocument(URL.createObjectURL(file)).promise;
  let text = '';
  for (let i = 1; i <= Math.min(pdf.numPages, 50); i++) {
    const page = await pdf.getPage(i);
    const content = await page.getTextContent();
    text += content.items.map(item => item.str).join(' ') + '\n';
  }
  return text;
}

async function generateQA(text) {
  try {
    const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': 'Bearer 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',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: "meta-llama/llama-4-maverick-17b-128e-instruct",
        messages: [{"role": "user", "content": `Create as many relevant and unique flashcard questions and answers as possible from this text. Ensure no duplicate questions or answers. Format as: Question 1: [question] Answer 1: [answer] Question 2: [question] Answer 2: [answer] etc. ${text}`}],
        temperature: 0.5,
        max_tokens: 1500,
        top_p: 1,
        stream: false,
        stop: null
      }),
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }

    const data = await response.json();
    const content = data.choices[0]?.message?.content || 'Question 1: Question Answer 1: ' + text;
    const regex = /Question (\d+):\s*(.+?)\s*Answer (\d+):\s*(.+?)(?=Question \d+:|$)/gs;
    const qas = [];
    let match;
    while ((match = regex.exec(content)) !== null) {
      qas.push({ front: match[2].trim(), back: match[4].trim() });
    }
    if (qas.length === 0) {
      qas.push({ front: 'Question', back: text });
    }
    // Remove duplicates
    const uniqueQAs = qas.filter((qa, index, self) =>
      index === self.findIndex(q => q.front === qa.front && q.back === qa.back)
    );
    return uniqueQAs;
  } catch (error) {
    console.error('QA generation failed:', error);
    return [{ front: 'Question', back: text }];
  }
}

// Account modal functions
let outsideClickHandler;

function openAccountModal() {
  const modal = document.getElementById('account-modal');
  const info = document.getElementById('account-info');
  const user = JSON.parse(localStorage.getItem('currentUser'));
  if (user) {
    info.innerHTML = `<p>Signed in as: ${user.name}</p><button class="auth-btn" onclick="logout()">Logout</button><br><button onclick="closeAccountModal()" style="background: none; border: none; color: #6c757d; cursor: pointer; margin: 1rem auto 0; display: block; text-align: center;">Close</button>`;
  } else {
    info.innerHTML = `<p>Not signed in</p><button class="auth-btn" onclick="window.location.href='sign-in.html'">Sign In</button><br><button onclick="closeAccountModal()" style="background: none; border: none; color: #6c757d; cursor: pointer; margin: 1rem auto 0; display: block; text-align: center;">Close</button>`;
  }
  modal.classList.add('show');
  outsideClickHandler = function(e) {
    if (e.target.id === 'account-modal') {
      closeAccountModal();
    }
  };
  document.addEventListener('click', outsideClickHandler);
}

function closeAccountModal() {
  document.getElementById('account-modal').classList.remove('show');
  if (outsideClickHandler) {
    document.removeEventListener('click', outsideClickHandler);
    outsideClickHandler = null;
  }
}

function logout() {
  localStorage.removeItem('currentUser');
  closeAccountModal();
  window.location.href = 'sign-in.html';
}

// Event listener for account link
document.getElementById('account-link').addEventListener('click', function(e) {
  e.preventDefault();
  openAccountModal();
});

// Sidebar toggle
document.getElementById('sidebar-toggle').addEventListener('click', () => {
  document.body.classList.toggle('sidebar-open');
  localStorage.setItem('sidebarOpen', document.body.classList.contains('sidebar-open'));
});

// Initialize sidebar state
if (localStorage.getItem('sidebarOpen') === 'true') {
  document.body.classList.add('sidebar-open');
}
document.body.classList.add('sidebar-initialized');

// Close sidebar when clicking outside
document.addEventListener('click', (e) => {
  const sidebar = document.querySelector('.sidebar');
  const toggle = document.getElementById('sidebar-toggle');
  const accountModal = document.getElementById('account-modal');
  if (!sidebar.contains(e.target) && !toggle.contains(e.target) && document.body.classList.contains('sidebar-open') && !accountModal.classList.contains('show')) {
    document.body.classList.remove('sidebar-open');
    localStorage.setItem('sidebarOpen', false);
  }
});
</script>

<script>
  const toggle = document.getElementById('sidebar-toggle');
  toggle.addEventListener('click', () => {
    document.body.classList.toggle('sidebar-closed');
  });
</script>

</body>
</html>